'use strict';

var path = require('path');
var _ = require('lodash');
var terminal = require('child_process').exec;
var noop = function() {};
var ignores = ['jquery', 'lodash', 'q'];

/**
 * Executes a command on the command line async.
 * @param {String} command
 * @param {Function} [callback]
 */
function execute(command, callback) {
    callback = callback || noop;

    terminal(command, function(error) {
        if (error) {
            console.log(error);
        }
        callback.apply(null, arguments);
    });
}

/**
 * Enumerates the same command over a string.  So it would
 * be like doing -x to 10 files (-x file1.js -x file2.js ...)
 * @param {String} command
 * @param {Array.<String>} arr
 * @returns {String}
 */
function commandEnumerate(command, arr) {

    var str = '';
    for (var i = 0; i < arr.length; i++) {
        str += command + ' ' + arr[i] + ' ';
    }

    return str
}

/**
 * Builds the browserify command.
 * @param {{
 *     entry: String,
 *     bundle: String,
 *     excludes: Array.<String>,
 *     ignores: Array.<String>
 * }} options
 */
function browserifyBuild(options) {

    var settings = _.extend({
        excludes: [],
        ignores: [],
        entry: '',
        bundle: '',
        requires: []
    }, options);

    var command = 'browserify ';

    command += commandEnumerate('-r', settings.requires);
    command += commandEnumerate('-x', settings.excludes);
    command += commandEnumerate('-i', settings.ignores);
    command += settings.entry + ' > ' + settings.dist + settings.bundle;

    return command;
}

/**
 * Simply logs out in green
 * @param {Grunt} grunt
 * @param {String} str
 */
function logGreen(grunt, str) {
    grunt.log.write(str.green);
}

/**
 * Simply logs out in cyan
 * @param {Grunt} grunt
 * @param {String} str
 */
function logCyan(grunt, str) {
    grunt.log.write(str.cyan);
}

/**
 * Simply logs out with new line
 * @param {Grunt} grunt
 * @param {String} str
 */
function logLn(grunt, str) {
    grunt.log.writeln(str);
}

/**
 * defaults the manifest so that there is no undefined errors.
 * @param {Object} manifest
 */
function defaultManifest(manifest) {
    manifest.folderExcludes = manifest.folderExcludes || [];
    manifest.excludes = manifest.excludes || [];

    return manifest;
}

/**
 * Builds the manifest operation.
 * @param {Grunt} grunt
 * @param {String} dist
 * @param {String} file
 */
function manifest(grunt, dist, file) {

    var manifest = defaultManifest(grunt.file.readJSON(file));
    var manifestDir = getManifestPath(file);
    manifest.dist = dist;

    for (var i = 0; i < manifest.folderExcludes.length; i++) {
        var pattern = [path.normalize(relativeFiles(manifest.folderExcludes[i]) + '/**/*.js')];
        var excludeFiles = grunt.file.expand(pattern);

        logCyan(grunt, 'Excluding(' + pattern + '):');
        logLn(grunt, '');
        manifest.excludes = manifest.excludes.concat(excludeFiles);
    }

    relativeFiles(manifest.excludes);
    relativeFiles(manifest.ignores);
    relativeFiles(manifest.requires);
    manifest.entry = relativeFiles(manifest.entry);

    // Finds all the package dependencies
    var command = browserifyBuild(manifest);

    logCyan(grunt, 'building: ');
    logLn(grunt, command);
    logLn(grunt, '');

    execute(command);

    /**
     * Makes all the files relative
     * @param {Array} varray
     */
    function relativeFiles(varray) {
        if (varray instanceof Array) {
            for (i = 0; i < varray.length; i++) {
                if (_.contains(ignores, varray[i])) {
                    continue;
                }
                varray[i] = './' + path.normalize(path.join(manifestDir, varray[i]));
            }
        } else {
            if (_.contains(ignores, varray)) {
                return varray;
            }
            varray = './' + path.normalize(path.join(manifestDir, varray));
        }
        return varray;
    }
}

/**
 * Gets the manifest file path.
 * @param {String} manifest
 * @returns {String}
 */
function getManifestPath(manifest) {
    return manifest.slice(0, manifest.length - 13);
}

/**
 * Manifest.JSON builds up from the manifest files the build commands
 * for browserify
 *
 * @type {{
 *     manifestAll: Function,
 *     manifest: Function
 * }}
 */
var manifestObj = {

    /**
     * Does a project wide manifest.
     * @param {{
     *     grunt: Grunt,
     *     dist: String
     * }} config
     */
    manifestAll: function(config) {

        var grunt = config.grunt;
        var dist = config.dist;

        var patterns = ['./**/manifest.json'];
        var files = grunt.file.expand(patterns);

        files.forEach(function(file) {
            manifestObj.manifest({
                grunt: grunt,
                dist: dist,
                manifest: file
            });
        });
    },

    /**
     * Builds the manifest one file at a time.
     * @param {{
     *     grunt: Grunt,
     *     dist: String,
     *     manifest: String
     * }} config
     */
    manifest: function(config) {

        var grunt = config.grunt;
        var dist = config.dist;
        var manFile = config.manifest;

        logLn(grunt, 'From Manifest.JSON');
        logGreen(grunt, '>> ');
        logLn(grunt, manFile);

        manifest(grunt, dist, manFile);
    }
};

module.exports = manifestObj;

